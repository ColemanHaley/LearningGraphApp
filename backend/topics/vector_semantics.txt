Speech and Language Processing . Daniel Jurafsky & James H . Martin . Copyright c © 2019 . All rights reserved . Draft of October 2 , 2019 . CHAPTER 6 Vector Semantics and Embed-dings The asphalt that Los Angeles is famous for occurs mainly on its freeways . But in the middle of the city is another patch of asphalt , the La Brea tar pits , and this asphalt preserves millions of fossil bones from the last of the Ice Ages of the Pleistocene Epoch . One of these fossils is the Smilodon , or sabre-toothed tiger , instantly rec - ognizable by its long canines . Five million years ago or so , a completely different sabre-tooth tiger called Thylacosmilus lived in Argentina and other parts of South Amer - ica . Thylacosmilus was a marsupial whereas Smilodon was a placental mammal , but Thy - lacosmilus had the same long upper canines and , like Smilodon , had a protective bone flange on the lower jaw . The similarity of these two mammals is one of many examples of parallel or convergent evolution , in which particular contexts or environments lead to the evolution of very similar structures in different species ( Gould , 1980 ) . The role of context is also important in the similarity of a less biological kind of organism : the word . Words that occur in similar contexts tend to have similar meanings . This link between similarity in how words are distributed and similarity in what they mean is called the distributional hypothesis . The hypothesis wasdistributionalhypothesis first formulated in the 1950s by linguists like Joos ( 1950 ) , Harris ( 1954 ) , and Firth ( 1957 ) , who noticed that words which are synonyms ( like oculist and eye-doctor ) tended to occur in the same environment ( e.g . , near words like eye or examined ) with the amount of meaning difference between two words “ corresponding roughly to the amount of difference in their environments ” ( Harris , 1954 , 157 ) . In this chapter we introduce vector semantics , which instantiates this linguisticvectorsemantics hypothesis by learning representations of the meaning of words , called embeddings , embeddings directly from their distributions in texts . These representations are used in every natural language processing application that makes use of meaning , and underlie the more powerful contextualized word representations like ELMo and BERT that we will introduce in Chapter 10 . These word representations are also the first example in this book of repre - sentation learning , automatically learning useful representations of the input text . representationlearning Finding such self-supervised ways to learn representations of the input , instead of creating representations by hand via feature engineering , is an important focus of NLP research ( Bengio et al . , 2013 ) . We’ll begin , however , by introducing some basic principles of word meaning , which will motivate the vector semantic models of this chapter as well as extensions that we’ll return to in Chapter 19 , Chapter 20 , and Chapter 21 . 2 CHAPTER 6 • VECTOR SEMANTICS AND EMBEDDINGS 6.1 Lexical Semantics How should we represent the meaning of a word ? In the N-gram models we saw in Chapter 3 , and in many traditional NLP applications , our only representation of a word is as a string of letters , or perhaps as an index in a vocabulary list . This representation is not that different from a tradition in philosophy , perhaps you’ve seen it in introductory logic classes , in which the meaning of words is represented by just spelling the word with small capital letters ; representing the meaning of “ dog ” as DOG , and “ cat ” as CAT ) . Representing the meaning of a word by capitalizing it is a pretty unsatisfactory model . You might have seen the old philosophy joke : Q : What’s the meaning of life ? A : LIFE Surely we can do better than this ! After all , we’ll want a model of word meaning to do all sorts of things for us . It should tell us that some words have similar mean - ings ( cat is similar to dog ) , other words are antonyms ( cold is the opposite of hot ) . It should know that some words have positive connotations ( happy ) while others have negative connotations ( sad ) . It should represent the fact that the meanings of buy , sell , and pay offer differing perspectives on the same underlying purchasing event ( If I buy something from you , you’ve probably sold it to me , and I likely paid you ) . More generally , a model of word meaning should allow us to draw useful infer - ences that will help us solve meaning-related tasks like question-answering , sum - marization , detecting paraphrases or plagiarism , and dialogue . In this section we summarize some of these desiderata , drawing on results in the linguistic study of word meaning , which is called lexical semantics ; we’ll return tolexicalsemantics and expand on this list in Chapter 19 . Lemmas and Senses Let’s start by looking at how one word ( we’ll choose mouse ) might be defined in a dictionary : 1 mouse ( N ) 1 . any of numerous small rodents . . . 2 . a hand-operated device that controls a cursor . . . Here the form mouse is the lemma , also called the citation form . The formlemma citation form mouse would also be the lemma for the word mice ; dictionaries don’t have separate definitions for inflected forms like mice . Similarly sing is the lemma for sing , sang , sung . In many languages the infinitive form is used as the lemma for the verb , so Spanish dormir “ to sleep ” is the lemma for duermes “ you sleep ” . The specific forms sung or carpets or sing or duermes are called wordforms . wordform As the example above shows , each lemma can have multiple meanings ; the lemma mouse can refer to the rodent or the cursor control device . We call each of these aspects of the meaning of mouse a word sense . The fact that lemmas can be polysemous ( have multiple senses ) can make interpretation difficult ( is someone who types “ mouse info ” into a search engine looking for a pet or a tool ? ) . Chapter 19 will discuss the problem of polysemy , and introduce word sense disambiguation , the task of determining which sense of a word is being used in a particular context . Synonymy One important component of word meaning is the relationship be - tween word senses . For example when one word has a sense whose meaning is 1 This example shortened from the online dictionary WordNet , discussed in Chapter 19 . 6.1 • LEXICAL SEMANTICS 3 identical to a sense of another word , or nearly identical , we say the two senses of those two words are synonyms . Synonyms include such pairs assynonym couch / sofa vomit / throw up filbert / hazelnut car / automobile A more formal definition of synonymy ( between words rather than senses ) is that two words are synonymous if they are substitutable one for the other in any sentence without changing the truth conditions of the sentence , the situations in which the sentence would be true . We often say in this case that the two words have the same propositional meaning . propositionalmeaning While substitutions between some pairs of words like car / automobile or wa - ter / H2O are truth preserving , the words are still not identical in meaning . Indeed , probably no two words are absolutely identical in meaning . One of the fundamen - tal tenets of semantics , called the principle of contrast ( Girard 1718 , Bréal 1897 , principle ofcontrast Clark 1987 ) , is the assumption that a difference in linguistic form is always associ - ated with at least some difference in meaning . For example , the word H2O is used in scientific contexts and would be inappropriate in a hiking guide — water would be more appropriate — and this difference in genre is part of the meaning of the word . In practice , the word synonym is therefore commonly used to describe a relationship of approximate or rough synonymy . Word Similarity While words don’t have many synonyms , most words do have lots of similar words . Cat is not a synonym of dog , but cats and dogs are certainly similar words . In moving from synonymy to similarity , it will be useful to shift from talking about relations between word senses ( like synonymy ) to relations between words ( like similarity ) . Dealing with words avoids having to commit to a particular representation of word senses , which will turn out to simplify our task . The notion of word similarity is very useful in larger semantic tasks . Know-similarity ing how similar two words are can help in computing how similar the meaning of two phrases or sentences are , a very important component of natural language un - derstanding tasks like question answering , paraphrasing , and summarization . One way of getting values for word similarity is to ask humans to judge how similar one word is to another . A number of datasets have resulted from such experiments . For example the SimLex-999 dataset ( Hill et al . , 2015 ) gives values on a scale from 0 to 10 , like the examples below , which range from near-synonyms ( vanish , disappear ) to pairs that scarcely seem to have anything in common ( hole , agreement ) : vanish disappear 9.8 behave obey 7.3 belief impression 5.95 muscle bone 3.65 modest flexible 0.98 hole agreement 0.3 Word Relatedness The meaning of two words can be related in ways other than similarity . One such class of connections is called word relatedness ( Budanitskyrelatedness and Hirst , 2006 ) , also traditionally called word association in psychology . association Consider the meanings of the words coffee and cup . Coffee is not similar to cup ; they share practically no features ( coffee is a plant or a beverage , while a cup is a manufactured object with a particular shape ) . But coffee and cup are clearly related ; they are associated by co-participating in an everyday event ( the event of drinking coffee out of a cup ) . Similarly the nouns 4 CHAPTER 6 • VECTOR SEMANTICS AND EMBEDDINGS scalpel and surgeon are not similar but are related eventively ( a surgeon tends to make use of a scalpel ) . One common kind of relatedness between words is if they belong to the same semantic field . A semantic field is a set of words which cover a particular semanticsemantic field domain and bear structured relations with each other . For example , words might be related by being in the semantic field of hospitals ( surgeon , scalpel , nurse , anesthetic , hospital ) , restaurants ( waiter , menu , plate , food , chef ) , or houses ( door , roof , kitchen , family , bed ) . Semantic fields are also related to topic models , like Latent Dirichlet Alloca-topic models tion , LDA , which apply unsupervised learning on large sets of texts to induce sets of associated words from text . Semantic fields and topic models are very useful tools for discovering topical structure in documents . In Chapter 19 we’ll introduce even more relations between senses , including hypernymy or IS-A , antonymy ( opposite meaning ) and meronymy ) ( part-whole relations ) . Semantic Frames and Roles Closely related to semantic fields is the idea of a semantic frame . A semantic frame is a set of words that denote perspectives orsemantic frame participants in a particular type of event . A commercial transaction , for example , is a kind of event in which one entity trades money to another entity in return for some good or service , after which the good changes hands or perhaps the service is performed . This event can be encoded lexically by using verbs like buy ( the event from the perspective of the buyer ) , sell ( from the perspective of the seller ) , pay ( focusing on the monetary aspect ) , or nouns like buyer . Frames have semantic roles ( like buyer , seller , goods , money ) , and words in a sentence can take on these roles . Knowing that buy and sell have this relation makes it possible for a system to know that a sentence like Sam bought the book from Ling could be paraphrased as Ling sold the book to Sam , and that Sam has the role of the buyer in the frame and Ling the seller . Being able to recognize such paraphrases is important for question answering , and can help in shifting perspective for machine translation . Connotation Finally , words have affective meanings or connotations . The wordconnotations connotation has different meanings in different fields , but here we use it to mean the aspects of a word’s meaning that are related to a writer or reader’s emotions , sentiment , opinions , or evaluations . For example some words have positive conno - tations ( happy ) while others have negative connotations ( sad ) . Some words describe positive evaluation ( great , love ) and others negative evaluation ( terrible , hate ) . Pos - itive or negative evaluation expressed through language is called sentiment , as wesentiment saw in Chapter 4 , and word sentiment plays a role in important tasks like sentiment analysis , stance detection , and many applications of natural language processing to the language of politics and consumer reviews . Early work on affective meaning ( Osgood et al . , 1957 ) found that words varied along three important dimensions of affective meaning . These are now generally called valence , arousal , and dominance , defined as follows : valence : the pleasantness of the stimulus arousal : the intensity of emotion provoked by the stimulus dominance : the degree of control exerted by the stimulus Thus words like happy or satisfied are high on valence , while unhappy or an - noyed are low on valence . Excited or frenzied are high on arousal , while relaxed or calm are low on arousal . Important or controlling are high on dominance , while awed or influenced are low on dominance . Each word is thus represented by three 6.2 • VECTOR SEMANTICS 5 numbers , corresponding to its value on each of the three dimensions , like the exam - ples below : Valence Arousal Dominance courageous 8.05 5.5 7.38 music 7.67 5.57 6.5 heartbreak 2.45 5.65 3.58 cub 6.71 3.95 4.24 life 6.68 5.59 5.89 Osgood et al . ( 1957 ) noticed that in using these 3 numbers to represent the meaning of a word , the model was representing each word as a point in a three - dimensional space , a vector whose three dimensions corresponded to the word’s rating on the three scales . This revolutionary idea that word meaning word could be represented as a point in space ( e.g . , that part of the meaning of heartbreak can be represented as the point [ 2.45,5.65,3.58 ] ) was the first expression of the vector semantics models that we introduce next . 6.2 Vector Semantics How can we build a computational model that successfully deals with the different aspects of word meaning we saw in the previous section ( word senses , word simi - larity and relatedness , lexical fields and frames , connotation ) ? A perfect model that completely deals with each of these aspects of word mean - ing turns out to be elusive . But the current best model , called vector semantics , vectorsemantics draws its inspiration from linguistic and philosophical work of the 1950 ’ s . During that period , the philosopher Ludwig Wittgenstein , skeptical of the possi - bility of building a completely formal theory of meaning definitions for each word , suggested instead that “ the meaning of a word is its use in the language ” ( Wittgen - stein , 1953 , PI 43 ) . That is , instead of using some logical language to define each word , we should define words by some representation of how the word was used by actual people in speaking and understanding . Linguists of the period like Joos ( 1950 ) , Harris ( 1954 ) , and Firth ( 1957 ) ( the lin - guistic distributionalists ) , came up with a specific idea for realizing Wittgenstein’s intuition : define a word by its environment or distribution in language use . A word’s distribution is the set of contexts in which it occurs , the neighboring words or gram - matical environments . The idea is that two words that occur in very similar dis - tributions ( that occur together with very similar words ) are likely to have the same meaning . Let’s see an example illustrating this distributionalist approach . Suppose you didn’t know what the Cantonese word ongchoi meant , but you do see it in the fol - lowing sentences or contexts : ( 6.1 ) Ongchoi is delicious sauteed with garlic . ( 6.2 ) Ongchoi is superb over rice . ( 6.3 ) . . . ongchoi leaves with salty sauces . . . And furthermore let’s suppose that you had seen many of these context words occurring in contexts like : ( 6.4 ) . . . spinach sauteed with garlic over rice . . . 6 CHAPTER 6 • VECTOR SEMANTICS AND EMBEDDINGS ( 6.5 ) . . . chard stems and leaves are delicious . . . ( 6.6 ) . . . collard greens and other salty leafy greens The fact that ongchoi occurs with words like rice and garlic and delicious and salty , as do words like spinach , chard , and collard greens might suggest to the reader that ongchoi is a leafy green similar to these other leafy greens . 2 We can do the same thing computationally by just counting words in the context of ongchoi ; we’ll tend to see words like sauteed and eaten and garlic . The fact that these words and other similar context words also occur around the word spinach or collard greens can help us discover the similarity between these words and ongchoi . Vector semantics thus combines two intuitions : the distributionalist intuition ( defining a word by counting what other words occur in its environment ) , and the vector intuition of Osgood et al . ( 1957 ) we saw in the last section on connotation : defining the meaning of a word w as a vector , a list of numbers , a point in N - dimensional space . There are various versions of vector semantics , each defining the numbers in the vector somewhat differently , but in each case the numbers are based in some way on counts of neighboring words . good nice bad worst not good wonderful amazing terrific dislike worse very good incredibly good fantastic incredibly badnow youi that with byto ’ s are is a than Figure 6.1 A two-dimensional ( t-SNE ) projection of embeddings for some words and phrases , showing that words with similar meanings are nearby in space . The original 60 - dimensional embeddings were trained for sentiment analysis . Simplified from Li et al . ( 2015 ) . The idea of vector semantics is thus to represent a word as a point in some multi - dimensional semantic space . Vectors for representing words are generally called embeddings , because the word is embedded in a particular vector space . Fig . 6.1embeddings displays a visualization of embeddings that were learned for a sentiment analysis task , showing the location of some selected words projected down from the original 60-dimensional space into a two dimensional space . Notice that positive and negative words seem to be located in distinct portions of the space ( and different also from the neutral function words ) . This suggests one of the great advantages of vector semantics : it offers a fine-grained model of meaning that lets us also implement word similarity ( and phrase similarity ) . For example , the sentiment analysis classifier we saw in Chapter 4 only works if enough of the important sentimental words that appear in the test set also appeared in the training set . But if words were represented as embeddings , we could assign sentiment as long as words with similar meanings as the test set words occurred in the training 2 It’s in fact Ipomoea aquatica , a relative of morning glory sometimes called water spinach in English . 6.3 • WORDS AND VECTORS 7 set . Vector semantic models are also extremely practical because they can be learned automatically from text without any complex labeling or supervision . As a result of these advantages , vector models of meaning are now the standard way to represent the meaning of words in NLP . In this chapter we’ll introduce the two most commonly used models . First is the tf-idf model , often used as a baseline , in which the meaning of a word is defined by a simple function of the counts of nearby words . We will see that this method results in very long vectors that are sparse , i.e . contain mostly zeros ( since most words simply never occur in the context of others ) . Then we’ll introduce the word2vec model , one of a family of models that are ways of constructing short , dense vectors that have useful semantic properties . We’ll also introduce the cosine , the standard way to use embeddings ( vectors ) to compute functions like semantic similarity , the similarity between two words , two sentences , or two documents , an important tool in practical applications like question answering , summarization , or automatic essay grading . 6.3 Words and Vectors Vector or distributional models of meaning are generally based on a co-occurrence matrix , a way of representing how often words co-occur . This matrix can be con - structed in various ways ; let’s begin by looking at one such co-occurrence matrix , a term-document matrix . 6.3.1 Vectors and documents In a term-document matrix , each row represents a word in the vocabulary and eachterm-documentmatrix column represents a document from some collection of documents . Fig . 6.2 shows a small selection from a term-document matrix showing the occurrence of four words in four plays by Shakespeare . Each cell in this matrix represents the number of times a particular word ( defined by the row ) occurs in a particular document ( defined by the column ) . Thus fool appeared 58 times in Twelfth Night . As You Like It Twelfth Night Julius Caesar Henry V battle 1 0 7 13 good 114 80 62 89 fool 36 58 1 4 wit 20 15 2 3 Figure 6.2 The term-document matrix for four words in four Shakespeare plays . Each cell contains the number of times the ( row ) word occurs in the ( column ) document . The term-document matrix of Fig . 6.2 was first defined as part of the vector space model of information retrieval ( Salton , 1971 ) . In this model , a document isvector spacemodel represented as a count vector , a column in Fig . 6.3 . To review some basic linear algebra , a vector is , at heart , just a list or arrayvector of numbers . So As You Like It is represented as the list [ 1,114,36,20 ] and Julius Caesar is represented as the list [ 7,62,1,2 ] . A vector space is a collection of vectors , vector space characterized by their dimension . In the example in Fig . 6.3 , the vectors are ofdimension dimension 4 , just so they fit on the page ; in real term-document matrices , the vectors representing each document would have dimensionality | V | , the vocabulary size . 8 CHAPTER 6 • VECTOR SEMANTICS AND EMBEDDINGS The ordering of the numbers in a vector space is not arbitrary ; each position indicates a meaningful dimension on which the documents can vary . Thus the first dimension for both these vectors corresponds to the number of times the word battle occurs , and we can compare each dimension , noting for example that the vectors for As You Like It and Twelfth Night have similar values ( 1 and 0 , respectively ) for the first dimension . As You Like It Twelfth Night Julius Caesar Henry V battle 1 0 7 13 good 114 80 62 89 fool 36 58 1 4 wit 20 15 2 3 Figure 6.3 The term-document matrix for four words in four Shakespeare plays . The red boxes show that each document is represented as a column vector of length four . We can think of the vector for a document as identifying a point in | V | - dimensional space ; thus the documents in Fig . 6.3 are points in 4-dimensional space . Since 4 - dimensional spaces are hard to draw in textbooks , Fig . 6.4 shows a visualization in two dimensions ; we’ve arbitrarily chosen the dimensions corresponding to the words battle and fool . 5 10 15 20 25 30 5 10 Henry V [ 4,13 ] As You Like It [ 36,1 ] Julius Caesar [ 1,7 ] ba ttl e fool Twelfth Night [ 58,0 ] 15 40 35 40 45 50 55 60 Figure 6.4 A spatial visualization of the document vectors for the four Shakespeare play documents , showing just two of the dimensions , corresponding to the words battle and fool . The comedies have high values for the fool dimension and low values for the battle dimension . Term-document matrices were originally defined as a means of finding similar documents for the task of document information retrieval . Two documents that are similar will tend to have similar words , and if two documents have similar words their column vectors will tend to be similar . The vectors for the comedies As You Like It [ 1,114,36,20 ] and Twelfth Night [ 0,80,58,15 ] look a lot more like each other ( more fools and wit than battles ) than they look like Julius Caesar [ 7,62,1,2 ] or Henry V [ 13,89,4,3 ] . This is clear with the raw numbers ; in the first dimension ( battle ) the comedies have low numbers and the others have high numbers , and we can see it visually in Fig . 6.4 ; we’ll see very shortly how to quantify this intuition more formally . A real term-document matrix , of course , wouldn’t just have 4 rows and columns , let alone 2 . More generally , the term-document matrix has | V | rows ( one for each word type in the vocabulary ) and D columns ( one for each document in the collec - tion ) ; as we’ll see , vocabulary sizes are generally in the tens of thousands , and the number of documents can be enormous ( think about all the pages on the web ) . 6.3 • WORDS AND VECTORS 9 Information retrieval ( IR ) is the task of finding the document d from the Dinformationretrieval documents in some collection that best matches a query q . For IR we’ll therefore also represent a query by a vector , also of length | V | , and we’ll need a way to compare two vectors to find how similar they are . ( Doing IR will also require efficient ways to store and manipulate these vectors by making use of the convenient fact that these vectors are sparse , i.e . , mostly zeros ) . Later in the chapter we’ll introduce some of the components of this vector com - parison process : the tf-idf term weighting , and the cosine similarity metric . 6.3.2 Words as vectors We’ve seen that documents can be represented as vectors in a vector space . But vector semantics can also be used to represent the meaning of words , by associating each word with a vector . The word vector is now a row vector rather than a column vector , and hence therow vector dimensions of the vector are different . The four dimensions of the vector for fool , [ 36,58,1,4 ] , correspond to the four Shakespeare plays . The same four dimensions are used to form the vectors for the other 3 words : wit , [ 20,15,2,3 ] ; battle , [ 1,0,7,13 ] ; and good [ 114,80,62,89 ] . Each entry in the vector thus represents the counts of the word’s occurrence in the document corresponding to that dimension . For documents , we saw that similar documents had similar vectors , because sim - ilar documents tend to have similar words . This same principle applies to words : similar words have similar vectors because they tend to occur in similar documents . The term-document matrix thus lets us represent the meaning of a word by the doc - uments it tends to occur in . However , it is most common to use a different kind of context for the dimensions of a word’s vector representation . Rather than the term-document matrix we use the term-term matrix , more commonly called the word-word matrix or the term-word-wordmatrix context matrix , in which the columns are labeled by words rather than documents . This matrix is thus of dimensionality | V | × | V | and each cell records the number of times the row ( target ) word and the column ( context ) word co-occur in some context in some training corpus . The context could be the document , in which case the cell represents the number of times the two words appear in the same document . It is most common , however , to use smaller contexts , generally a window around the word , for example of 4 words to the left and 4 words to the right , in which case the cell represents the number of times ( in some training corpus ) the column word occurs in such a ± 4 word window around the row word . For example here is one example each of some words in their windows : is traditionally followed by cherry pie , a traditional dessert often mixed , such as strawberry rhubarb pie . Apple pie computer peripherals and personal digital assistants . These devices usually a computer . This includes information available on the internet If we then take every occurrence of each word ( say strawberry ) and count the con - text words around it , we get a word-word co-occurrence matrix . Fig . 6.5 shows a simplified subset of the word-word co-occurrence matrix for these four words com - puted from the Wikipedia corpus ( Davies , 2015 ) . Note in Fig . 6.5 that the two words cherry and strawberry are more similar to each other ( both pie and sugar tend to occur in their window ) than they are to other words like digital ; conversely , digital and information are more similar to each other than , say , to strawberry . Fig . 6.6 shows a spatial visualization . 10 CHAPTER 6 • VECTOR SEMANTICS AND EMBEDDINGS aardvark . . . computer data result pie sugar . . . cherry 0 . . . 2 8 9 442 25 strawberry 0 . . . 0 0 1 60 19 digital 0 . . . 1670 1683 85 5 4 information 0 . . . 3325 3982 378 5 13 Figure 6.5 Co-occurrence vectors for four words in the Wikipedia corpus , showing six of the dimensions ( hand-picked for pedagogical purposes ) . The vector for digital is outlined in red . Note that a real vector would have vastly more dimensions and thus be much sparser . 1000 2000 3000 4000 1000 2000 digital [ 1683,1670 ] co m pu te r data information [ 3982,3325 ] 3000 4000 Figure 6.6 A spatial visualization of word vectors for digital and information , showing just two of the dimensions , corresponding to the words data and computer . Note that | V | , the length of the vector , is generally the size of the vocabulary , usually between 10,000 and 50,000 words ( using the most frequent words in the training corpus ; keeping words after about the most frequent 50,000 or so is gener - ally not helpful ) . But of course since most of these numbers are zero these are sparse vector representations , and there are efficient algorithms for storing and computing with sparse matrices . Now that we have some intuitions , let’s move on to examine the details of com - puting word similarity . Afterwards we’ll discuss the tf-idf method of weighting cells . 6.4 Cosine for measuring similarity To define similarity between two target words v and w , we need a measure for taking two such vectors and giving a measure of vector similarity . By far the most common similarity metric is the cosine of the angle between the vectors . The cosine — like most measures for vector similarity used in NLP — is based on the dot product operator from linear algebra , also called the inner product : dot product inner product dot product ( v , w ) = v · w = N ∑ i = 1 viwi = v1w1 + v2w2 + . . . + vNwN ( 6.7 ) As we will see , most metrics for similarity between vectors are based on the dot product . The dot product acts as a similarity metric because it will tend to be high just when the two vectors have large values in the same dimensions . Alternatively , vectors that have zeros in different dimensions — orthogonal vectors — will have a dot product of 0 , representing their strong dissimilarity . 6.4 • COSINE FOR MEASURING SIMILARITY 11 This raw dot product , however , has a problem as a similarity metric : it favors long vectors . The vector length is defined asvector length | v | = √ √ √ √ N ∑ i = 1 v2i ( 6.8 ) The dot product is higher if a vector is longer , with higher values in each dimension . More frequent words have longer vectors , since they tend to co-occur with more words and have higher co-occurrence values with each of them . The raw dot product thus will be higher for frequent words . But this is a problem ; we’d like a similarity metric that tells us how similar two words are regardless of their frequency . The simplest way to modify the dot product to normalize for the vector length is to divide the dot product by the lengths of each of the two vectors . This normalized dot product turns out to be the same as the cosine of the angle between the two vectors , following from the definition of the dot product between two vectors a and b : a · b = | a | | b | cosθ a · b | a | | b | = cosθ ( 6.9 ) The cosine similarity metric between two vectors v and w thus can be computed as : cosine cosine ( v , w ) = v · w | v | | w | = N ∑ i = 1 viwi √ √ √ √ N ∑ i = 1 v2i √ √ √ √ N ∑ i = 1 w2i ( 6.10 ) For some applications we pre-normalize each vector , by dividing it by its length , creating a unit vector of length 1 . Thus we could compute a unit vector from a byunit vector dividing it by | a | . For unit vectors , the dot product is the same as the cosine . The cosine value ranges from 1 for vectors pointing in the same direction , through 0 for vectors that are orthogonal , to - 1 for vectors pointing in opposite directions . But raw frequency values are non-negative , so the cosine for these vectors ranges from 0 – 1 . Let’s see how the cosine computes which of the words cherry or digital is closer in meaning to information , just using raw counts from the following shortened table : pie data computer cherry 442 8 2 digital 5 1683 1670 information 5 3982 3325 cos ( cherry , information ) = 442 ∗ 5 + 8 ∗ 3982 + 2 ∗ 3325 √ 4422 + 82 + 22 √ 52 + 39822 + 33252 = . 017 cos ( digital , information ) = 5 ∗ 5 + 1683 ∗ 3982 + 1670 ∗ 3325 √ 52 + 16832 + 16702 √ 52 + 39822 + 33252 = . 996 The model decides that information is way closer to digital than it is to cherry , a result that seems sensible . Fig . 6.7 shows a visualization . 12 CHAPTER 6 • VECTOR SEMANTICS AND EMBEDDINGS 500 1000 1500 2000 2500 3000 500 digital cherry information D im en si on 1 : ‘ pi e ’ Dimension 2 : ‘ computer ’ Figure 6.7 A ( rough ) graphical demonstration of cosine similarity , showing vectors for three words ( cherry , digital , and information ) in the two dimensional space defined by counts of the words computer and pie nearby . Note that the angle between digital and information is smaller than the angle between cherry and information . When two vectors are more similar , the cosine is larger but the angle is smaller ; the cosine has its maximum ( 1 ) when the angle between two vectors is smallest ( 0 ◦ ) ; the cosine of all other angles is less than 1 . 6.5 TF-IDF : Weighing terms in the vector The co-occurrence matrix in Fig . 6.5 represented each cell by the raw frequency of the co-occurrence of two words . It turns out , however , that simple frequency isn’t the best measure of association between words . One problem is that raw frequency is very skewed and not very discriminative . If we want to know what kinds of contexts are shared by cherry and strawberry but not by digital and information , we’re not going to get good discrimi - nation from words like the , it , or they , which occur frequently with all sorts of words and aren’t informative about any particular word . We saw this also in Fig . 6.3 for the Shakespeare corpus ; the dimension for the word good is not very discrimina - tive between plays ; good is simply a frequent word and has roughly equivalent high frequencies in each of the plays . It’s a bit of a paradox . Words that occur nearby frequently ( maybe pie nearby cherry ) are more important than words that only appear once or twice . Yet words that are too frequent — ubiquitous , like the or good — are unimportant . How can we balance these two conflicting constraints ? The tf-idf algorithm ( the ‘ - ’ here is a hyphen , not a minus sign ) is the product of two terms , each term capturing one of these two intuitions : The first is the term frequency ( Luhn , 1957 ) : the frequency of the word t in theterm frequency document d . We can just use the raw count as the term frequency : tft , d = count ( t , d ) ( 6.11 ) Alternatively we can squash the raw frequency a bit , by using the log10 of the fre - quency instead . The intuition is that a word appearing 100 times in a document doesn’t make that word 100 times more likely to be relevant to the meaning of the document . Because we can’t take the log of 0 , we normally add 1 to the count : 3 tft , d = log10 ( count ( t , d ) + 1 ) ( 6.12 ) If we use log weighting , terms which occur 10 times in a document would have a tf = 2 , 100 times in a document tf = 3 , 1000 times tf = 4 , and so on . 3 Or we can use this alternative : tft , d = { 1 + log10 count ( t , d ) if count ( t , d ) > 0 0 otherwise 6.5 • TF-IDF : WEIGHING TERMS IN THE VECTOR 13 The second factor is used to give a higher weight to words that occur only in a few documents . Terms that are limited to a few documents are useful for discrimi - nating those documents from the rest of the collection ; terms that occur frequently across the entire collection aren’t as helpful . The document frequency dft of adocumentfrequency term t is the number of documents it occurs in . Document frequency is not the same as the collection frequency of a term , which is the total number of times the word appears in the whole collection in any document . Consider in the collection of Shakespeare’s 37 plays the two words Romeo and action . The words have identical collection frequencies ( they both occur 113 times in all the plays ) but very different document frequencies , since Romeo only occurs in a single play . If our goal is find documents about the romantic tribulations of Romeo , the word Romeo should be highly weighted , but not action : Collection Frequency Document Frequency Romeo 113 1 action 113 31 We emphasize discriminative words like Romeo via the inverse document fre - quency or idf term weight ( Sparck Jones , 1972 ) . The idf is defined using the frac-idf tion N / dft , where N is the total number of documents in the collection , and dft is the number of documents in which term t occurs . The fewer documents in which a term occurs , the higher this weight . The lowest weight of 1 is assigned to terms that occur in all the documents . It’s usually clear what counts as a document : in Shake - speare we would use a play ; when processing a collection of encyclopedia articles like Wikipedia , the document is a Wikipedia page ; in processing newspaper articles , the document is a single article . Occasionally your corpus might not have appropri - ate document divisions and you might need to break up the corpus into documents yourself for the purposes of computing idf . Because of the large number of documents in many collections , this measure too is usually squashed with a log function . The resulting definition for inverse document frequency ( idf ) is thus idft = log10 ( N dft ) ( 6.13 ) Here are some idf values for some words in the Shakespeare corpus , ranging from extremely informative words which occur in only one play like Romeo , to those that occur in a few like salad or Falstaff , to those which are very common like fool or so common as to be completely non-discriminative since they occur in all 37 plays like good or sweet . 4 Word df idf Romeo 1 1.57 salad 2 1.27 Falstaff 4 0.967 forest 12 0.489 battle 21 0.246 wit 34 0.037 fool 36 0.012 good 37 0 sweet 37 0 4 Sweet was one of Shakespeare’s favorite adjectives , a fact probably related to the increased use of sugar in European recipes around the turn of the 16th century ( Jurafsky , 2014 , p . 175 ) . 14 CHAPTER 6 • VECTOR SEMANTICS AND EMBEDDINGS The tf-idf weighted value wt , d for word t in document d thus combines termtf-idf frequency tft , d ( defined either by Eq . 6.11 or by Eq . 6.12 ) with idf from Eq . 6.13 : wt , d = tft , d × idft ( 6.14 ) Fig . 6.8 applies tf-idf weighting to the Shakespeare term-document matrix in Fig . 6.2 , using the tf equation Eq . 6.12 . Note that the tf-idf values for the dimension corre - sponding to the word good have now all become 0 ; since this word appears in every document , the tf-idf algorithm leads it to be ignored in any comparison of the plays . Similarly , the word fool , which appears in 36 out of the 37 plays , has a much lower weight . As You Like It Twelfth Night Julius Caesar Henry V battle 0.074 0 0.22 0.28 good 0 0 0 0 fool 0.019 0.021 0.0036 0.0083 wit 0.049 0.044 0.018 0.022 Figure 6.8 A tf-idf weighted term-document matrix for four words in four Shakespeare plays , using the counts in Fig . 6.2 . For example the 0.049 value for wit in As You Like It is the product of tf = log10 ( 20 + 1 ) = 1.322 and idf = . 037 . Note that the idf weighting has eliminated the importance of the ubiquitous word good and vastly reduced the impact of the almost-ubiquitous word fool . The tf-idf weighting is the way for weighting co-occurrence matrices in infor - mation retrieval , but also plays a role in many other aspects of natural language processing . It’s also a great baseline , the simple thing to try first . We’ll look at other weightings like PPMI ( Positive Pointwise Mutual Information ) in Section 6.7 . 6.6 Applications of the tf-idf vector model In summary , the vector semantics model we’ve described so far represents a target word as a vector with dimensions corresponding to all the words in the vocabulary ( length | V | , with vocabularies of 20,000 to 50,000 ) , which is also sparse ( most values are zero ) . The values in each dimension are the frequency with which the target word co-occurs with each neighboring context word , weighted by tf-idf . The model computes the similarity between two words x and y by taking the cosine of their tf-idf vectors ; high cosine , high similarity . This entire model is sometimes referred to for short as the tf-idf model , after the weighting function . One common use for a tf-idf model is to compute word similarity , a useful tool for tasks like finding word paraphrases , tracking changes in word meaning , or au - tomatically discovering meanings of words in different corpora . For example , we can find the 10 most similar words to any target word w by computing the cosines between w and each of the V − 1 other words , sorting , and looking at the top 10 . The tf-idf vector model can also be used to decide if two documents are similar . We represent a document by taking the vectors of all the words in the document , and computing the centroid of all those vectors . The centroid is the multidimensionalcentroid version of the mean ; the centroid of a set of vectors is a single vector that has the minimum sum of squared distances to each of the vectors in the set . Given k word vectors w1 , w2 , . . . , wk , the centroid document vector d is : documentvector d = w1 + w2 + . . . + wk k ( 6.15 ) 6.7 • OPTIONAL : POINTWISE MUTUAL INFORMATION ( PMI ) 15 Given two documents , we can then compute their document vectors d1 and d2 , and estimate the similarity between the two documents by cos ( d1 , d2 ) . Document similarity is also useful for all sorts of applications ; information re - trieval , plagiarism detection , news recommender systems , and even for digital hu - manities tasks like comparing different versions of a text to see which are similar to each other . 6.7 Optional : Pointwise Mutual Information ( PMI ) An alternative weighting function to tf-idf is called PPMI ( positive pointwise mutual information ) . PPMI draws on the intuition that the best way to weigh the association between two words is to ask how much more the two words co-occur in our corpus than we would have a priori expected them to appear by chance . Pointwise mutual information ( Fano , 1961 ) 5 is one of the most important con - pointwise mutual information cepts in NLP . It is a measure of how often two events x and y occur , compared with what we would expect if they were independent : I ( x , y ) = log2 P ( x , y ) P ( x ) P ( y ) ( 6.17 ) The pointwise mutual information between a target word w and a context word c ( Church and Hanks 1989 , Church and Hanks 1990 ) is then defined as : PMI ( w , c ) = log2 P ( w , c ) P ( w ) P ( c ) ( 6.18 ) The numerator tells us how often we observed the two words together ( assuming we compute probability by using the MLE ) . The denominator tells us how often we would expect the two words to co-occur assuming they each occurred indepen - dently ; recall that the probability of two independent events both occurring is just the product of the probabilities of the two events . Thus , the ratio gives us an esti - mate of how much more the two words co-occur than we expect by chance . PMI is a useful tool whenever we need to find words that are strongly associated . PMI values range from negative to positive infinity . But negative PMI values ( which imply things are co-occurring less often than we would expect by chance ) tend to be unreliable unless our corpora are enormous . To distinguish whether two words whose individual probability is each 10 − 6 occur together less often than chance , we would need to be certain that the probability of the two occurring to - gether is significantly different than 10 − 12 , and this kind of granularity would require an enormous corpus . Furthermore it’s not clear whether it’s even possible to evalu - ate such scores of ‘ unrelatedness ’ with human judgments . For this reason it is more common to use Positive PMI ( called PPMI ) which replaces all negative PMI valuesPPMI 5 Pointwise mutual information is based on the mutual information between two random variables X and Y , which is defined as : I ( X , Y ) = ∑ x ∑ y P ( x , y ) log2 P ( x , y ) P ( x ) P ( y ) ( 6.16 ) In a confusion of terminology , Fano used the phrase mutual information to refer to what we now call pointwise mutual information and the phrase expectation of the mutual information for what we now call mutual information 16 CHAPTER 6 • VECTOR SEMANTICS AND EMBEDDINGS with zero ( Church and Hanks 1989 , Dagan et al . 1993 , Niwa and Nitta 1994 ) 6 : PPMI ( w , c ) = max ( log2 P ( w , c ) P ( w ) P ( c ) , 0 ) ( 6.19 ) More formally , let’s assume we have a co-occurrence matrix F with W rows ( words ) and C columns ( contexts ) , where fi j gives the number of times word wi occurs in context c j . This can be turned into a PPMI matrix where ppmii j gives the PPMI value of word wi with context c j as follows : pi j = fi j ∑ W i = 1 ∑ C j = 1 fi j pi ∗ = ∑ C j = 1 fi j ∑ W i = 1 ∑ C j = 1 fi j p ∗ j = ∑ W i = 1 fi j ∑ W i = 1 ∑ C j = 1 fi j ( 6.20 ) PPMIi j = max ( log2 pi j pi ∗ p ∗ j , 0 ) ( 6.21 ) Let’s see some PPMI calculations . We’ll use Fig . 6.9 , which repeats Fig . 6.5 plus all the count marginals , and let’s pretend for ease of calculation that these are the only words / contexts that matter . computer data result pie sugar count ( w ) cherry 2 8 9 442 25 486 strawberry 0 0 1 60 19 80 digital 1670 1683 85 5 4 3447 information 3325 3982 378 5 13 7703 count ( context ) 4997 5673 473 512 61 11716 Figure 6.9 Co-occurrence counts for four words in 5 contexts in the Wikipedia corpus , together with the marginals , pretending for the purpose of this calculation that no other words / contexts matter . Thus for example we could compute PPMI ( w = information , c = data ) , assuming we pretended that Fig . 6.5 encompassed all the relevant word contexts / dimensions , as follows : P ( w = information , c = data ) = 3982 11716 = . 3399 P ( w = information ) = 7703 11716 = . 6575 P ( c = data ) = 5673 11716 = . 4842 ppmi ( information , data ) = log2 ( . 3399 / ( . 6575 ∗ . 4842 ) ) = . 0944 Fig . 6.10 shows the joint probabilities computed from the counts in Fig . 6.9 , and Fig . 6.11 shows the PPMI values . Not surprisingly , cherry and strawberry are highly associated with both pie and sugar , and data is mildly associated with information . PMI has the problem of being biased toward infrequent events ; very rare words tend to have very high PMI values . One way to reduce this bias toward low frequency events is to slightly change the computation for P ( c ) , using a different function Pα ( c ) that raises the probability of the context word to the power of α : PPMIα ( w , c ) = max ( log2 P ( w , c ) P ( w ) Pα ( c ) , 0 ) ( 6.22 ) 6 Positive PMI also cleanly solves the problem of what to do with zero counts , using 0 to replace the − ∞ from log ( 0 ) . 6.8 • WORD2VEC 17 p ( w , context ) p ( w ) computer data result pie sugar p ( w ) cherry 0.0002 0.0007 0.0008 0.0377 0.0021 0.0415 strawberry 0.0000 0.0000 0.0001 0.0051 0.0016 0.0068 digital 0.1425 0.1436 0.0073 0.0004 0.0003 0.2942 information 0.2838 0.3399 0.0323 0.0004 0.0011 0.6575 p ( context ) 0.4265 0.4842 0.0404 0.0437 0.0052 Figure 6.10 Replacing the counts in Fig . 6.5 with joint probabilities , showing the marginals around the outside . computer data result pie sugar cherry 0 0 0 4.38 3.30 strawberry 0 0 0 4.10 5.51 digital 0.18 0.01 0 0 0 information 0.02 0.09 0.28 0 0 Figure 6.11 The PPMI matrix showing the association between words and context words , computed from the counts in Fig . 6.10 . Note that most of the 0 PPMI values are ones that had a negative PMI ; for example PMI ( cherry , computer ) = - 6.7 , meaning that cherry and computer co-occur on Wikipedia less often than we would expect by chance , and with PPMI we replace negative values by zero . Pα ( c ) = count ( c ) α ∑ c count ( c ) α ( 6.23 ) Levy et al . ( 2015 ) found that a setting of α = 0.75 improved performance of embeddings on a wide range of tasks ( drawing on a similar weighting used for skip - grams described below in Eq . 6.32 ) . This works because raising the count to α = 0.75 increases the probability assigned to rare contexts , and hence lowers their PMI ( Pα ( c ) > P ( c ) when c is rare ) . Another possible solution is Laplace smoothing : Before computing PMI , a small constant k ( values of 0.1-3 are common ) is added to each of the counts , shrinking ( discounting ) all the non-zero values . The larger the k , the more the non-zero counts are discounted . 6.8 Word2vec In the previous sections we saw how to represent a word as a sparse , long vector with dimensions corresponding to the words in the vocabulary , and whose values were tf - idf or PPMI functions of the count of the word co-occurring with each neighboring word . In this section we turn to an alternative method for representing a word : the use of vectors that are short ( of length perhaps 50-1000 ) and dense ( most values are non-zero ) . It turns out that dense vectors work better in every NLP task than sparse vec - tors . While we don’t completely understand all the reasons for this , we have some intuitions . First , dense vectors may be more successfully included as features in machine learning systems ; for example if we use 100-dimensional word embed - dings as features , a classifier can just learn 100 weights to represent a function of word meaning ; if we instead put in a 50,000 dimensional vector , a classifier would have to learn tens of thousands of weights for each of the sparse dimensions . Sec - ond , because they contain fewer parameters than sparse vectors of explicit counts , 18 CHAPTER 6 • VECTOR SEMANTICS AND EMBEDDINGS dense vectors may generalize better and help avoid overfitting . Finally , dense vec - tors may do a better job of capturing synonymy than sparse vectors . For example , car and automobile are synonyms ; but in a typical sparse vector representation , the car dimension and the automobile dimension are distinct dimensions . Because the relationship between these two dimensions is not modeled , sparse vectors may fail to capture the similarity between a word with car as a neighbor and a word with automobile as a neighbor . In this section we introduce one method for very dense , short vectors , skip - gram with negative sampling , sometimes called SGNS . The skip-gram algorithmskip-gram SGNS is one of two algorithms in a software package called word2vec , and so sometimes word2vec the algorithm is loosely referred to as word2vec ( Mikolov et al . 2013 , Mikolov et al . 2013a ) . The word2vec methods are fast , efficient to train , and easily avail - able online with code and pretrained embeddings . We point to other embedding methods , like the equally popular GloVe ( Pennington et al . , 2014 ) , at the end of the chapter . The intuition of word2vec is that instead of counting how often each word w oc - curs near , say , apricot , we’ll instead train a classifier on a binary prediction task : “ Is word w likely to show up near apricot ? ” We don’t actually care about this prediction task ; instead we’ll take the learned classifier weights as the word embeddings . The revolutionary intuition here is that we can just use running text as implicitly supervised training data for such a classifier ; a word s that occurs near the target word apricot acts as gold ‘ correct answer ’ to the question “ Is word w likely to show up near apricot ? ” This avoids the need for any sort of hand-labeled supervision signal . This idea was first proposed in the task of neural language modeling , when Bengio et al . ( 2003 ) and Collobert et al . ( 2011 ) showed that a neural language model ( a neural network that learned to predict the next word from prior words ) could just use the next word in running text as its supervision signal , and could be used to learn an embedding representation for each word as part of doing this prediction task . We’ll see how to do neural networks in the next chapter , but word2vec is a much simpler model than the neural network language model , in two ways . First , word2vec simplifies the task ( making it binary classification instead of word pre - diction ) . Second , word2vec simplifies the architecture ( training a logistic regression classifier instead of a multi-layer neural network with hidden layers that demand more sophisticated training algorithms ) . The intuition of skip-gram is : 1 . Treat the target word and a neighboring context word as positive examples . 2 . Randomly sample other words in the lexicon to get negative samples . 3 . Use logistic regression to train a classifier to distinguish those two cases . 4 . Use the regression weights as the embeddings . 6.8.1 The classifier Let’s start by thinking about the classification task , and then turn to how to train . Imagine a sentence like the following , with a target word apricot , and assume we’re using a window of ± 2 context words : . . . lemon , a [ tablespoon of apricot jam , a ] pinch . . . c1 c2 t c3 c4 Our goal is to train a classifier such that , given a tuple ( t , c ) of a target word t paired with a candidate context word c ( for example ( apricot , jam ) , or perhaps 6.8 • WORD2VEC 19 ( apricot , aardvark ) ) it will return the probability that c is a real context word ( true for jam , false for aardvark ) : P ( + | t , c ) ( 6.24 ) The probability that word c is not a real context word for t is just 1 minus Eq . 6.24 : P ( − | t , c ) = 1 − P ( + | t , c ) ( 6.25 ) How does the classifier compute the probability P ? The intuition of the skip - gram model is to base this probability on similarity : a word is likely to occur near the target if its embedding is similar to the target embedding . How can we compute similarity between embeddings ? Recall that two vectors are similar if they have a high dot product ( cosine , the most popular similarity metric , is just a normalized dot product ) . In other words : Similarity ( t , c ) ≈ t · c ( 6.26 ) Of course , the dot product t · c is not a probability , it’s just a number ranging from − ∞ to ∞ . ( Recall , for that matter , that cosine isn’t a probability either ) . To turn the dot product into a probability , we’ll use the logistic or sigmoid function σ ( x ) , the fundamental core of logistic regression : σ ( x ) = 1 1 + e − x ( 6.27 ) The probability that word c is a real context word for target word t is thus computed as : P ( + | t , c ) = 1 1 + e − t·c ( 6.28 ) The sigmoid function just returns a number between 0 and 1 , so to make it a proba - bility we’ll need to make sure that the total probability of the two possible events ( c being a context word , and c not being a context word ) sums to 1 . The probability that word c is not a real context word for t is thus : P ( − | t , c ) = 1 − P ( + | t , c ) = e − t·c 1 + e − t·c ( 6.29 ) Equation 6.28 gives us the probability for one word , but we need to take account of the multiple context words in the window . Skip-gram makes the strong but very useful simplifying assumption that all context words are independent , allowing us to just multiply their probabilities : P ( + | t , c1 : k ) = k ∏ i = 1 1 1 + e − t·ci ( 6.30 ) logP ( + | t , c1 : k ) = k ∑ i = 1 log 1 1 + e − t·ci ( 6.31 ) In summary , skip-gram trains a probabilistic classifier that , given a test target word t and its context window of k words c1 : k , assigns a probability based on how similar 20 CHAPTER 6 • VECTOR SEMANTICS AND EMBEDDINGS this context window is to the target word . The probability is based on applying the logistic ( sigmoid ) function to the dot product of the embeddings of the target word with each context word . We could thus compute this probability if only we had embeddings for each target word and context word in the vocabulary . Let’s now turn to learning these embeddings ( which is the real goal of training this classifier in the first place ) . 6.8.2 Learning skip-gram embeddings Word2vec learns embeddings by starting with an initial set of embedding vectors and then iteratively shifting the embedding of each word w to be more like the em - beddings of words that occur nearby in texts , and less like the embeddings of words that don’t occur nearby . Let’s start by considering a single piece of training data : . . . lemon , a [ tablespoon of apricot jam , a ] pinch . . . c1 c2 t c3 c4 This example has a target word t ( apricot ) , and 4 context words in the L = ± 2 window , resulting in 4 positive training instances ( on the left below ) : positive examples + t c apricot tablespoon apricot of apricot jam apricot a negative examples - t c t c apricot aardvark apricot seven apricot my apricot forever apricot where apricot dear apricot coaxial apricot if For training a binary classifier we also need negative examples . In fact skip - gram uses more negative examples than positive examples ( with the ratio between them set by a parameter k ) . So for each of these ( t , c ) training instances we’ll create k negative samples , each consisting of the target t plus a ‘ noise word ’ . A noise word is a random word from the lexicon , constrained not to be the target word t . The right above shows the setting where k = 2 , so we’ll have 2 negative examples in the negative training set − for each positive example t , c . The noise words are chosen according to their weighted unigram frequency pα ( w ) , where α is a weight . If we were sampling according to unweighted fre - quency p ( w ) , it would mean that with unigram probability p ( “ the ” ) we would choose the word the as a noise word , with unigram probability p ( “ aardvark ” ) we would choose aardvark , and so on . But in practice it is common to set α = . 75 , i.e . use the weighting p 3 4 ( w ) : Pα ( w ) = count ( w ) α ∑ w ′ count ( w ′ ) α ( 6.32 ) Setting α = . 75 gives better performance because it gives rare noise words slightly higher probability : for rare words , Pα ( w ) > P ( w ) . To visualize this intuition , it might help to work out the probabilities for an example with two events , P ( a ) = . 99 and P ( b ) = . 01 : Pα ( a ) = . 99.75 . 99.75 + . 01.75 = . 97 Pα ( b ) = . 01.75 . 99.75 + . 01.75 = . 03 ( 6.33 ) 6.8 • WORD2VEC 21 Given the set of positive and negative training instances , and an initial set of em - beddings , the goal of the learning algorithm is to adjust those embeddings such that we • Maximize the similarity of the target word , context word pairs ( t , c ) drawn from the positive examples • Minimize the similarity of the ( t , c ) pairs drawn from the negative examples . We can express this formally over the whole training set as : L ( θ ) = ∑ ( t , c ) ∈ + logP ( + | t , c ) + ∑ ( t , c ) ∈ − logP ( − | t , c ) ( 6.34 ) If we look at one word / context pair ( t , c ) with its k noise words n1 . . . nk , the learning objective L is : L ( θ ) = logP ( + | t , c ) + k ∑ i = 1 logP ( − | t , ni ) = logσ ( c · t ) + k ∑ i = 1 logσ ( − ni · t ) = log 1 1 + e − c·t + k ∑ i = 1 log 1 1 + eni·t ( 6.35 ) That is , we want to maximize the dot product of the word with the actual context words , and minimize the dot products of the word with the k negative sampled non - neighbor words . We can then use stochastic gradient descent to train to this objective , iteratively modifying the parameters ( the embeddings for each target word t and each context word or noise word c in the vocabulary ) to maximize the objective . Note that the skip-gram model thus actually learns two separate embeddings for each word w : the target embedding t and the context embedding c . Thesetargetembedding context embedding embeddings are stored in two matrices , the target matrix T and the context matrix C . So each row i of the target matrix T is the 1 × d vector embedding ti for word i in the vocabulary V , and each column j of the context matrix C is a d × 1 vector embedding c j for word j in V . Fig . 6.12 shows an intuition of the learning task for the embeddings encoded in these two matrices . Just as in logistic regression , then , the learning algorithm starts with randomly initialized W and C matrices , and then walks through the training corpus using gra - dient descent to move W and C so as to maximize the objective in Eq . 6.35 . Thus the matrices W and C function as the parameters θ that logistic regression is tuning . Once the embeddings are learned , we’ll have two embeddings for each word wi : ti and ci . We can choose to throw away the C matrix and just keep W , in which case each word i will be represented by the vector ti . Alternatively we can add the two embeddings together , using the summed em - bedding ti + ci as the new d-dimensional embedding , or we can concatenate them into an embedding of dimensionality 2d . As with the simple count-based methods like tf-idf , the context window size L affects the performance of skip-gram embeddings , and experiments often tune the parameter L on a devset . One difference from the count-based methods is that for skip-grams , the larger the window size the more computation the algorithm requires for training ( more neighboring words must be predicted ) . 22 CHAPTER 6 • VECTOR SEMANTICS AND EMBEDDINGS 1 . i . . . . . . V 1.2 … … . j … … . … … . … k … … V 1 . . . d T C 1 . . . … d increase similarity ( apricot , jam ) ti . cj jam apricot aa rdv ark decrease similarity ( apricot , aardvark ) ti . ck “ … apricot jam … ” ne igh bo r w ord ran do m no ise w ord target word Figure 6.12 The skip-gram model tries to shift embeddings so the target embeddings ( here for apricot ) are closer to ( have a higher dot product with ) context embeddings for nearby words ( here jam ) and further from ( have a lower dot product with ) context embeddings for words that don’t occur nearby ( here aardvark ) . 6.9 Visualizing Embeddings “ I see well in many dimensions as long as the dimensions are around two . ” The late economist Martin Shubek Visualizing embeddings is an important goal in helping understand , apply , and improve these models of word meaning . But how can we visualize a ( for example ) 100-dimensional vector ? The simplest way to visualize the meaning of a word w embedded in a space is to list the most similar words to w by sorting the vectors for all words in the vocabulary by their cosine with the vector for w . For example the 7 closest words to frog using the GloVe embeddings are : frogs , toad , litoria , leptodactylidae , rana , lizard , and eleutherodactylus ( Pennington et al . , 2014 ) Rohde , Gonnerman , Plaut Modeling Word Meaning Using Lexical Co-Occurrence HEAD HANDFACE DOG AMERICA CAT EYE EUROPE FOOT CHINA FRANCE CHICAGO ARM FINGER NOSE LEG RUSSIA MOUSE AFRICA ATLANTA EAR SHOULDER ASIA COW BULL PUPPY LION HAWAII MONTREAL TOKYO TOE MOSCOW TOOTH NASHVILLE BRAZIL WRIST KITTEN ANKLE TURTLE OYSTER Figure 8 : Multidimensional scaling for three noun classes . WRIST ANKLE SHOULDER ARM LEG HAND FOOT HEAD NOSE FINGER TOE FACE EAR EYE TOOTH DOG CAT PUPPY KITTEN COW MOUSE TURTLE OYSTER LION BULL CHICAGO ATLANTA MONTREAL NASHVILLE TOKYO CHINA RUSSIA AFRICA ASIA EUROPE AMERICA BRAZIL MOSCOW FRANCE HAWAII Figure 9 : Hierarchical clustering for three noun classes using distances based on vector correlations . 20 Yet another visualization method is to use a clus - tering algorithm to show a hierarchical representa - tion of which words are similar to others in the em - bedding space . The uncaptioned example on the right uses hierarchical clustering of some embedding vectors for nouns as a visualization method ( Rohde et al . , 2006 ) . Probably the most common visualization method , however , is to project the 100 dimensions of a word down into 2 dimensions . Fig . 6.1 showed one such visualization , as does Fig . 6.13 , using a projection method called t-SNE ( van der Maaten and Hinton , 2008 ) . 6.10 Semantic properties of embeddings Vector semantic models have a number of parameters . One parameter that is relevant to both sparse tf-idf vectors and dense word2vec vectors is the size of the context 6.10 • SEMANTIC PROPERTIES OF EMBEDDINGS 23 window used to collect counts . This is generally between 1 and 10 words on each side of the target word ( for a total context of 3-20 words ) . The choice depends on the goals of the representation . Shorter context windows tend to lead to representations that are a bit more syntactic , since the information is coming from immediately nearby words . When the vectors are computed from short context windows , the most similar words to a target word w tend to be semantically similar words with the same parts of speech . When vectors are computed from long context windows , the highest cosine words to a target word w tend to be words that are topically related but not similar . For example Levy and Goldberg ( 2014a ) showed that using skip-gram with a window of ± 2 , the most similar words to the word Hogwarts ( from the Harry Potter series ) were names of other fictional schools : Sunnydale ( from Buffy the Vampire Slayer ) or Evernight ( from a vampire series ) . With a window of ± 5 , the most similar words to Hogwarts were other words topically related to the Harry Potter series : Dumbledore , Malfoy , and half-blood . It’s also often useful to distinguish two kinds of similarity or association between words ( Schütze and Pedersen , 1993 ) . Two words have first-order co-occurrencefirst-orderco-occurrence ( sometimes called syntagmatic association ) if they are typically nearby each other . Thus wrote is a first-order associate of book or poem . Two words have second-order co-occurrence ( sometimes called paradigmatic association ) if they have similarsecond-orderco-occurrence neighbors . Thus wrote is a second-order associate of words like said or remarked . Analogy Another semantic property of embeddings is their ability to capture re - lational meanings . Mikolov et al . ( 2013b ) and Levy and Goldberg ( 2014b ) show that the offsets between vector embeddings can capture some analogical relations between words . For example , the result of the expression vector ( ‘ king ’ ) - vec - tor ( ‘ man ’ ) + vector ( ‘ woman ’ ) is a vector close to vector ( ‘ queen ’ ) ; the left panel in Fig . 6.13 visualizes this , again projected down into 2 dimensions . Similarly , they found that the expression vector ( ‘ Paris ’ ) - vector ( ‘ France ’ ) + vector ( ‘ Italy ’ ) results in a vector that is very close to vector ( ‘ Rome ’ ) . ( a ) ( b ) Figure 6.13 Relational properties of the vector space , shown by projecting vectors onto two dimensions . ( a ) ’ king ’ - ’ man ’ + ’ woman ’ is close to ’ queen ’ ( b ) offsets seem to capture comparative and superlative morphology ( Pennington et al . , 2014 ) . Embeddings and Historical Semantics : Embeddings can also be a useful tool for studying how meaning changes over time , by computing multiple embedding 24 CHAPTER 6 • VECTOR SEMANTICS AND EMBEDDINGS spaces , each from texts written in a particular time period . For example Fig . 6.14 shows a visualization of changes in meaning in English words over the last two centuries , computed by building separate embedding spaces for each decade from historical corpora like Google N-grams ( Lin et al . , 2012 ) and the Corpus of Histori - cal American English ( Davies , 2012 ) . CHAPTER 5 . DYNAMIC SOCIAL REPRESENTATIONS OF WORD MEANING79 Figure 5.1 : Two-dimensional visualization of semantic change in English using SGNS vectors ( see Section 5.8 for the visualization algorithm ) . A , The word gay shifted from meaning “ cheerful ” or “ frolicsome ” to referring to homosexuality . A , In the early 20th century broadcast referred to “ casting out seeds ” ; with the rise of television and radio its meaning shifted to “ transmitting signals ” . C , Awful underwent a process of pejoration , as it shifted from meaning “ full of awe ” to meaning “ terrible or appalling ” [ 212 ] . that adverbials ( e.g . , actually ) have a general tendency to undergo subjectification where they shift from objective statements about the world ( e.g . , “ Sorry , the car is actually broken ” ) to subjective statements ( e.g . , “ I can’t believe he actually did that ” , indicating surprise / disbelief ) . 5.2.2 Computational linguistic studies There are also a number of recent works analyzing semantic change using computational methods . [ 200 ] use latent semantic analysis to analyze how word meanings broaden and narrow over time . [ 113 ] use raw co-occurrence vectors to perform a number of historical case-studies on semantic change , and [ 252 ] perform a similar set of small - scale case-studies using temporal topic models . [ 87 ] construct point-wise mutual information-based embeddings and found that semantic changes uncovered by their method had reasonable agreement with human judgments . [ 129 ] and [ 119 ] use “ neural ” word-embedding methods to detect linguistic change points . Finally , [ 257 ] analyze historical co-occurrences to test whether synonyms tend to change in similar ways . Figure 6.14 A t-SNE visualization of the semantic change of 3 words in English using word2vec vectors . The modern sense of each word , and the grey context words , are com - puted from the most recent ( modern ) time-point embedding space . Earlier points are com - puted from earlier historical embedding spaces . The visualizations show the changes in the word gay from meanings related to “ cheerful ” or “ frolicsome ” to referring to homosexuality , the development of the modern “ transmission ” sense of broadcast from its original sense of sowing seeds , and the pejoration of the word awful as it shifted from meaning “ full of awe ” to meaning “ terrible or appalling ” ( Hamilton et al . , 2016 ) . 6.11 Bias and Embeddings In addition to their ability to learn word meaning from text , embeddings , alas , also reproduce the implicit biases and stereotypes that were latent in the text . Recall that embeddings model analogical relations ; ‘ queen ’ as the closest word to ‘ king ’ - ‘ man ’ + ‘ woman ’ implies the analogy man : woman : : king : queen . But embedding analogies also exhibit gender stereotypes . For example Bolukbasi et al . ( 2016 ) find that the closest occupation to ‘ man ’ - ‘ computer programmer ’ + ‘ woman ’ in word2vec em - beddings trained on news text is ‘ homemaker ’ , and that the embeddings similarly suggest the analogy ‘ father ’ is to ‘ doctor ’ as ‘ mother ’ is to ‘ nurse ’ . Algorithms that use embeddings as part of a search for potential programmers or doctors might thus incorrectly downweight documents with women’s names . Embeddings also encode the implicit associations that are a property of human reasoning . The Implicit Association Test ( Greenwald et al . , 1998 ) measures peo - ple’s associations between concepts ( like ‘ flowers ’ or ‘ insects ’ ) and attributes ( like ‘ pleasantness ’ and ‘ unpleasantness ’ ) by measuring differences in the latency with which they label words in the various categories . 7 Using such methods , people in the United States have been shown to associate African-American names with unpleasant words ( more than European-American names ) , male names more with 7 Roughly speaking , if humans associate ‘ flowers ’ with ‘ pleasantness ’ and ‘ insects ’ with ‘ unpleasant - ness ’ , when they are instructed to push a green button for ‘ flowers ’ ( daisy , iris , lilac ) and ‘ pleasant words ’ ( love , laughter , pleasure ) and a red button for ‘ insects ’ ( flea , spider , mosquito ) and ‘ unpleasant words ’ ( abuse , hatred , ugly ) they are faster than in an incongruous condition where they push a red button for ‘ flowers ’ and ‘ unpleasant words ’ and a green button for ‘ insects ’ and ‘ pleasant words ’ . 6.12 • EVALUATING VECTOR MODELS 25 mathematics and female names with the arts , and old people’s names with unpleas - ant words ( Greenwald et al . 1998 , Nosek et al . 2002a , Nosek et al . 2002b ) . Caliskan et al . ( 2017 ) replicated all these findings of implicit associations using GloVe vectors and cosine similarity instead of human latencies . For example African-American names like ‘ Leroy ’ and ‘ Shaniqua ’ had a higher GloVe cosine with unpleasant words while European-American names ( ‘ Brad ’ , ‘ Greg ’ , ‘ Courtney ’ ) had a higher cosine with pleasant words . Any embedding-aware algorithm that made use of word senti - ment could thus lead to bias against African Americans . Recent research focuses on ways to try to remove these kinds of biases , for ex - ample by developing a transformation of the embedding space that removes gender stereotypes but preserves definitional gender ( Bolukbasi et al . 2016 , Zhao et al . 2017 ) or changing the training procedure ( Zhao et al . , 2018 ) . However , although these sorts of debiasing may reduce bias in embeddings , they do not eliminate it ( Gonen anddebiasing Goldberg , 2019 ) , and this remains an open problem . Historical embeddings are also being used to measure biases in the past . Garg et al . ( 2018 ) used embeddings from historical texts to measure the association be - tween embeddings for occupations and embeddings for names of various ethnici - ties or genders ( for example the relative cosine similarity of women’s names versus men’s to occupation words like ‘ librarian ’ or ‘ carpenter ’ ) across the 20th century . They found that the cosines correlate with the empirical historical percentages of women or ethnic groups in those occupations . Historical embeddings also repli - cated old surveys of ethnic stereotypes ; the tendency of experimental participants in 1933 to associate adjectives like ‘ industrious ’ or ‘ superstitious ’ with , e.g . , Chinese ethnicity , correlates with the cosine between Chinese last names and those adjectives using embeddings trained on 1930s text . They also were able to document historical gender biases , such as the fact that embeddings for adjectives related to competence ( ‘ smart ’ , ‘ wise ’ , ‘ thoughtful ’ , ‘ resourceful ’ ) had a higher cosine with male than fe - male words , and showed that this bias has been slowly decreasing since 1960 . We return in later chapters to this question about the role of bias in natural language processing . 6.12 Evaluating Vector Models The most important evaluation metric for vector models is extrinsic evaluation on tasks ; adding them as features into any NLP task and seeing whether this improves performance over some other model . Nonetheless it is useful to have intrinsic evaluations . The most common metric is to test their performance on similarity , computing the correlation between an algorithm’s word similarity scores and word similarity ratings assigned by humans . WordSim-353 ( Finkelstein et al . , 2002 ) is a commonly used set of ratings from 0 to 10 for 353 noun pairs ; for example ( plane , car ) had an average score of 5.77 . SimLex-999 ( Hill et al . , 2015 ) is a more difficult dataset that quantifies similarity ( cup , mug ) rather than relatedness ( cup , coffee ) , and including both concrete and abstract adjective , noun and verb pairs . The TOEFL dataset is a set of 80 questions , each consisting of a target word with 4 additional word choices ; the task is to choose which is the correct synonym , as in the example : Levied is closest in meaning to : imposed , believed , requested , correlated ( Landauer and Dumais , 1997 ) . All of these datasets present words without context . Slightly more realistic are intrinsic similarity tasks that include context . The 26 CHAPTER 6 • VECTOR SEMANTICS AND EMBEDDINGS Stanford Contextual Word Similarity ( SCWS ) dataset ( Huang et al . , 2012 ) and the Word-in-Context ( WiC ) dataset ( Pilehvar and Camacho-Collados , 2019 ) offers richer evaluation scenarios . SCWS gives human judgments on 2,003 pairs of words in their sentential context , while WiC gives target words in two sentential contexts that are either in the same or different senses ; see Section ? ? . The semantic textual similarity task ( Agirre et al . 2012 , Agirre et al . 2015 ) evaluates the performance of sentence - level similarity algorithms , consisting of a set of pairs of sentences , each pair with human-labeled similarity scores . Another task used for evaluate is an analogy task , where the system has to solve problems of the form a is to b as c is to d , given a , b , and c and having to find d . Thus given Athens is to Greece as Oslo is to , the system must fill in the word Norway . Or more syntactically-oriented examples : given mouse , mice , and dollar the system must return dollars . Large sets of such tuples have been created ( Mikolov et al . 2013 , Mikolov et al . 2013b ) . 6.13 Summary • In vector semantics , a word is modeled as a vector — a point in high-dimensional space , also called an embedding . • Vector semantic models fall into two classes : sparse and dense . • In sparse models like tf-idf each dimension corresponds to a word in the vo - cabulary V ; cells in sparse models are functions of co-occurrence counts . The term-document matrix has rows for each word ( term ) in the vocabulary and a column for each document . The word-context matrix has a row for each ( target ) word in the vocabulary and a column for each context term in the vocabulary . • The most widely used sparse weighting is tf-idf , which weights each cell by its term frequency and inverse document frequency . PPMI ( pointwise pos - itive mutual information ) is an alternative weighting scheme to tf-idf . • Dense vector models have dimensionality 50 – 1000 and the dimensions are harder to interpret . Word2vec algorithms like skip-gram are a popular and efficient way to compute dense embeddings . Skip-gram trains a logistic re - gression classifier to compute the probability that two words are ‘ likely to occur nearby in text ’ . This probability is computed from the dot product be - tween the embeddings for the two words . • Skip-gram uses stochastic gradient descent to train the classifier , by learning embeddings that have a high dot product with embeddings of words that occur nearby and a low dot product with noise words . • Other important embedding algorithms include GloVe , a method based on ra - tios of word co-occurrence probabilities , and fasttext , an open-source library for computing word embeddings by summing embeddings of the bag of char - acter n-grams that make up a word . • Whether using sparse or dense vectors , word and document similarities are computed by some function of the dot product between vectors . The cosine of two vectors — a normalized dot product — is the most popular such metric . BIBLIOGRAPHICAL AND HISTORICAL NOTES 27 Bibliographical and Historical Notes The idea of vector semantics arose out of research in the 1950s in three distinct fields : linguistics , psychology , and computer science , each of which contributed a fundamental aspect of the model . The idea that meaning is related to the distribution of words in context was widespread in linguistic theory of the 1950s , among distributionalists like Zellig Harris , Martin Joos , and J . R . Firth , and semioticians like Thomas Sebeok . As Joos ( 1950 ) put it , the linguist’s “ meaning ” of a morpheme . . . is by definition the set of conditional probabilities of its occurrence in context with all other morphemes . The idea that the meaning of a word might be modeled as a point in a multi - dimensional semantic space came from psychologists like Charles E . Osgood , who had been studying how people responded to the meaning of words by assigning val - ues along scales like happy / sad or hard / soft . Osgood et al . ( 1957 ) proposed that the meaning of a word in general could be modeled as a point in a multidimensional Euclidean space , and that the similarity of meaning between two words could be modeled as the distance between these points in the space . A final intellectual source in the 1950s and early 1960s was the field then called mechanical indexing , now known as information retrieval . In what became knownmechanicalindexing as the vector space model for information retrieval ( Salton 1971 , Sparck Jones 1986 ) , researchers demonstrated new ways to define the meaning of words in terms of vec - tors ( Switzer , 1965 ) , and refined methods for word similarity based on measures of statistical association between words like mutual information ( Giuliano , 1965 ) and idf ( Sparck Jones , 1972 ) , and showed that the meaning of documents could be represented in the same vector spaces used for words . More distantly related is the idea of defining words by a vector of discrete fea - tures , which has a venerable history in our field , with roots at least as far back as Descartes and Leibniz ( Wierzbicka 1992 , Wierzbicka 1996 ) . By the middle of the 20th century , beginning with the work of Hjelmslev ( Hjelmslev , 1969 ) and fleshed out in early models of generative grammar ( Katz and Fodor , 1963 ) , the idea arose of representing meaning with semantic features , symbols that represent some sort ofsemanticfeature primitive meaning . For example words like hen , rooster , or chick , have something in common ( they all describe chickens ) and something different ( their age and sex ) , representable as : hen + female , + chicken , + adult rooster - female , + chicken , + adult chick + chicken , - adult The dimensions used by vector models of meaning to define words , however , are only abstractly related to this idea of a small fixed number of hand-built dimensions . Nonetheless , there has been some attempt to show that certain dimensions of em - bedding models do contribute some specific compositional aspect of meaning like these early semantic features . The first use of dense vectors to model word meaning was the latent seman - tic indexing ( LSI ) model ( Deerwester et al . , 1988 ) recast as LSA ( latent seman - tic analysis ) ( Deerwester et al . , 1990 ) . In LSA singular value decomposition — SVD — is applied to a term-document matrix ( each cell weighted by log frequencySVD and normalized by entropy ) , and then the first 300 dimensions are used as the LSA 28 CHAPTER 6 • VECTOR SEMANTICS AND EMBEDDINGS embedding . Singular Value Decomposition ( SVD ) is a method for finding the most important dimensions of a data set , those dimensions along which the data varies the most . LSA was then quickly widely applied : as a cognitive model Landauer and Dumais ( 1997 ) , and tasks like spell checking ( Jones and Martin , 1997 ) , lan - guage modeling ( Bellegarda 1997 , Coccaro and Jurafsky 1998 , Bellegarda 2000 ) morphology induction ( Schone and Jurafsky 2000 , Schone and Jurafsky 2001 ) , and essay grading ( Rehder et al . , 1998 ) . Related models were simultaneously devel - oped and applied to word sense disambiguation by Schütze ( 1992 ) . LSA also led to the earliest use of embeddings to represent words in a probabilistic classifier , in the logistic regression document router of Schütze et al . ( 1995 ) . The idea of SVD on the term-term matrix ( rather than the term-document matrix ) as a model of mean - ing for NLP was proposed soon after LSA by Schütze ( 1992 ) . Schütze applied the low-rank ( 97-dimensional ) embeddings produced by SVD to the task of word sense disambiguation , analyzed the resulting semantic space , and also suggested possible techniques like dropping high-order dimensions . See Schütze ( 1997 ) . A number of alternative matrix models followed on from the early SVD work , including Probabilistic Latent Semantic Indexing ( PLSI ) ( Hofmann , 1999 ) , Latent Dirichlet Allocation ( LDA ) ( Blei et al . , 2003 ) , and Non-negative Matrix Factoriza - tion ( NMF ) ( Lee and Seung , 1999 ) . By the next decade , Bengio et al . ( 2003 ) and Bengio et al . ( 2006 ) showed that neural language models could also be used to develop embeddings as part of the task of word prediction . Collobert and Weston ( 2007 ) , Collobert and Weston ( 2008 ) , and Collobert et al . ( 2011 ) then demonstrated that embeddings could play a role for rep - resenting word meanings for a number of NLP tasks . Turian et al . ( 2010 ) compared the value of different kinds of embeddings for different NLP tasks . Mikolov et al . ( 2011 ) showed that recurrent neural nets could be used as language models . The idea of simplifying the hidden layer of these neural net language models to create the skip-gram ( and also CBOW ) algorithms was proposed by Mikolov et al . ( 2013 ) . The negative sampling training algorithm was proposed in Mikolov et al . ( 2013a ) . Studies of embeddings include results showing an elegant mathematical relation - ship between sparse and dense embeddings ( Levy and Goldberg , 2014c ) , as well as numerous surveys of embeddings and their parameterizations . ( Bullinaria and Levy 2007 , Bullinaria and Levy 2012 , Lapesa and Evert 2014 , Kiela and Clark 2014 , Levy et al . 2015 ) . The most widely-used embedding model besides word2vec is GloVe ( Penning - ton et al . , 2014 ) . The name stands for Global Vectors , because the model is based on capturing global corpus statistics . GloVe is based on ratios of probabilities from the word-word co-occurrence matrix , combining the intuitions of count-based models like PPMI while also capturing the linear structures used by methods like word2vec . An extension of word2vec , fasttext ( Bojanowski et al . , 2017 ) , deals with un-fasttext known words and sparsity in languages with rich morphology , by using subword models . Each word in fasttext is represented as itself plus a bag of constituent n - grams , with special boundary symbols < and > added to each word . For example , with n = 3 the word where would be represented by the character n-grams : < wh , whe , her , ere , re > plus the sequence < where > Then a skipgram embedding is learned for each constituent n-gram , and the word where is represented by the sum of all of the embeddings of its constituent n-grams . EXERCISES 29 A fasttext open-source library , including pretrained embeddings for 157 languages , is available at https://fasttext.cc . There are many other embedding algorithms , using methods like non-negative matrix factorization ( Fyshe et al . , 2015 ) , or by converting sparse PPMI embeddings to dense vectors by using SVD ( Levy and Goldberg , 2014c ) . In Chapter 10 we introduce contextual embeddings like ELMo ( Peters et al . , 2018 ) and BERT ( Devlin et al . , 2019 ) in which the representation for a word is contextual , a function of the entire input sentence . See Manning et al . ( 2008 ) for a deeper understanding of the role of vectors in in - formation retrieval , including how to compare queries with documents , more details on tf-idf , and issues of scaling to very large datasets . Cruse ( 2004 ) is a useful introductory linguistic text on lexical semantics . 
